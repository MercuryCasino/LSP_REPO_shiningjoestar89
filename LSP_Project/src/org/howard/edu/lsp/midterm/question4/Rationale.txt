Rationale for Smart-Campus Device System Design

Why is Device defined as an abstract class?

The Device class is defined as abstract because it represents a general concept rather than a concrete object you can create directly. 
It contains an abstract method, getStatus(), which forces all subclasses to provide their own specific implementation for how they report 
their status. This ensures that every concrete device (like a DoorLock or Camera) has this capability, but it acknowledges that the 
implementation details will differ for each one.

How do the Networked and BatteryPowered interfaces add behavior to your concrete classes?

The Networked and BatteryPowered interfaces add optional "capabilities" or behaviors to the concrete classes. 
They define a "contract" for what it means to be networkable or battery-powered. This allows unrelated classes 
like DoorLock and Camera to share common behaviors (like connect() or getBatteryPercent()) without being forced 
into a rigid class hierarchy. This makes the design flexible, as you can "mix and match" these capabilities for 
any new devices created in the future.

Is this design an example of multiple inheritance in Java? Explain why or why not.

No, this design is not an example of multiple inheritance. Java does not support multiple inheritance of classes 
(a class cannot extend more than one other class). Instead, this design demonstrates a core Java feature where a 
class can implement multiple interfaces. While a class like DoorLock inherits characteristics from both Device and 
Networked, it only inherits implementation (code and fields) from the single Device class. From the interfaces, 
it only inherits the method signatures (the "contract"), which it must then implement itself.